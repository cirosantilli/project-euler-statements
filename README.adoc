= Project Euler Statements
:docinfo:
:idprefix:
:idseparator: -
:sectanchors:
:sectlinks:
:sectnumlevels: 6
:sectnums:
:toc: macro
:toclevels: 6
:toc-title:

This repo contains link:https://projecteuler.net[Project Euler] problem statements, downloaded and converted to Markdown.

This repo was created to have a better input data source to feed LLMs to try and solve and Lean autoformalize all Project Euler problems in one go.

The main reasons for creating this repo are:

* stop pinging their server without need
* Codex CLI sometimes tells me it can't access the problem statement. I'm not sure if this is due to robots.txt like restrictions or other restrictions. I don't know and I don't want to know.
* I don't like feeding their ugly HTML to my poor LLMs :-) They deserve some nice markdown!

Together with the solutions from https://github.com/lucky-bai/projecteuler-solutions this makes for a nice little mathematics dataset :-)

toc::[]

== Generate the data

[source,python]
----
virtualenv -p python3 .venv
. .venv/bin/activate
pip install -r requirements.txt
./download.sh
./html2md.py
./extract_metadata.py
----

== Folder structure

* link:data/minimal/[]: HTML from `https://projecteuler.net/minimal=X` e.g. https://projecteuler.net/minimal=949
* link:data/problem/[]: HTML from `https://projecteuler.net/problem=X` e.g. https://projecteuler.net/problem=949
* link:data/documents/[]: files from under `https://projecteuler.net/resources/documents/` e.g. https://projecteuler.net/resources/documents/0042_words.txt at link:data/documents/0042_words.txt[data/documents/0042_words.txt]. These are required as input data to solve some of the problems.
* link:data/md/[]: local conversion of the above HTML downloads to a nice Markdown format
* link:data/lean/[]: formal <<lean>> statements of the problems
* link:data/meta/[]: JSON problem metadata extracted from the HTML e.g.: link:data/meta/1.json[data/meta/1.json] contains:
+
[source,json]
----
{
  "title": "Multiples of 3 or 5",
  "date": "2001-10-05T18:00:00"
}
----

== Lean

This section is about the folder ink:data/lean/[] which contains link:https://lean-lang.org/[Lean] formalizations of Project Euler problems.

Best Lean autoformalization prompt so far:

----
Convert Project Euler N described at ../md/<N>.md statement into a formal lean statement in ProjectEulerStatements/P<N>.lean. Put all definitions of that lean file under namespace ProjectEulerStatements.P<N>. Produce the simplest naive function which matches the problem statement as close as possible and name it "naive". Add a /-- -/ docstring above naive explaining what it does. noncomputable functions are fine, but partial is not, if you have partial also produce a proof of termination. If you find two close approaches name the second one "naive2" and prove equivalence if easy. Add lean "example" statements with native_decide as asserts for any test values given in the problem statement. Ensure that lake -R build works for that file. Don't cheat with fuel, try to make naive generic within reason, and state any formal hypothesis needed if you have an informal argument for it. We can prove them in a second pass.
----

We have manually inspected the following statements to ensure that they match up with our interpretation of Project Euler statements.

Full inspection, we have read and understood the definition of `naive` and any `example` to a good degree. Not necessarily proof details but we believe Lean:

* 1-5
* 13-14
* link:data/lean/ProjectEulerStatements/P67.lean[]

Notes within those:

* link:data/lean/ProjectEulerStatements/P5.lean[]: `Finset.lcm` felt like cheating! TODO: add a `naive2` without mathlib.
* link:data/lean/ProjectEulerStatements/P13.lean[]: this problem is hilariously brute-forceable by anything with arbitrary precision arithmetic like Python, or even pen and paper. It clearly has C-int limitations in mind. Lol.
* link:data/lean/ProjectEulerStatements/P14.lean[]: requires the Collatz conjecture. I think I'll add as an axiom rather than getting Codex to prove it today ;-)
* link:data/lean/ProjectEulerStatements/P67.lean[]: is the same as P18, so we encode it as such

`naive` signature check only:

* link:data/lean/ProjectEulerStatements/P11.lean[]: naive input format only
* link:data/lean/ProjectEulerStatements/P12.lean[]: the ideal formulation would be `naive (n : Nat)` returning "the first triangle number to have over `n` divisors?". Codex swears that this result known, it's just a question of how easy it is to formulate. We might go for `axiom` if it turns out too hard.
* link:data/lean/ProjectEulerStatements/P18.lean[]
* link:data/lean/ProjectEulerStatements/P22.lean[]
* link:data/lean/ProjectEulerStatements/P24.lean[]
* link:data/lean/ProjectEulerStatements/P25.lean[]
* link:data/lean/ProjectEulerStatements/P27.lean[]
* link:data/lean/ProjectEulerStatements/P29.lean[]
* link:data/lean/ProjectEulerStatements/P30.lean[]
* link:data/lean/ProjectEulerStatements/P33.lean[]: going to try to generalize it to "N digits" rather than the fixed 2. If it turns out hard we can prove only for 2.
* link:data/lean/ProjectEulerStatements/P43.lean[]: going to leave this other ugly digits problem without input parameter
* link:data/lean/ProjectEulerStatements/P47.lean[]
* link:data/lean/ProjectEulerStatements/P49.lean[]: yet another ugly digits one. Generalized as much as possible, we'll see.

Notes within those:

* link:data/lean/ProjectEulerStatements/P19.lean[]: is a bloody nightmare to encode as you need to think about the formal definition of a date! As such, it is also one of the most useful problems perhaps for practical programming usage.
* link:data/lean/ProjectEulerStatements/P27.lean[]: this one requires proof that you can't have infinitely many consecutive primes of the form $n^2 + an + b$. Cute.

== Licenses

* link:data/[data/]: CC BY-NC-SA 4.0 as per Project Euler's license https://projecteuler.net/copyright
* code: BSD 3-Clause

Tested on Python 3.13.7, Ubuntu 25.10.
